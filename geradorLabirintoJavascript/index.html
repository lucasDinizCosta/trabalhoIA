<DOCTYPE! html>
<html lang="pt-br" dir="ltr">
  <head>
    <meta charset="utf-8">
    <script src="cell.js"></script>
    <title>Maze Generator</title>
    <style> body {padding: 20px; margin: 0;} canvas {vertical-align: top;} </style>

    <style>
      body {
          background-color: lightblue;
          color:black;
      }
    </style>
    <style type="text/css">
    * {margin: 0; padding: 0;}
    #container {display: flex; height: 100%; width:100%; font-size: 0;}
    #left, #middle, #right {display: inline-block; *display: inline; zoom: 1; vertical-align: top; font-size: 15px;}
    #left {margin-right: 10px;}
    #middle {flex:1; background: yellow; border:2px solid black ; margin-right: 10px;}
    #right {flex:1; background: yellow; border:2px solid black ; }
    canvas{border:2px solid black ; }
    /*div.container{
      width: 110px;
      height: 110px;
      overflow: scroll;
    }*/
    </style>
  </head>
  <body>
    <h1 align="center"><u>Trabalho de Inteligência Artificial</u> (2019/1)</h1>
    <br></br>
    <h2>&emsp;&emsp;Tema: Buscas em um labirinto </h2>
    <h2>&emsp;&emsp;Estratégia de geração do labirinto: backtrack recursivo(Recursive backtracker) </h3>
    <br></br>
    <h2>&emsp;&emsp;Geração de labirinto</h2>
    <br></br>
    <label><b>Linhas: </b></label>
    <input id="numLinhas" type="number" min="20" max="200">
    <label><b>Colunas: </b></label>
    <input id="numColunas" type="number" min="20" max="200">
    <label><b>Largura celula: </b></label>
    <input id="numLarguraCelula" type="number" min="20" max="40">
    <button onclick="funcaoBotaoGerarCompleto()">Gerar(Completo)</button>
    <button onclick="funcaoBotaoGerarPassoAPasso()">Gerar(Passo a passo)</button>
    <br></br>

    <div id="container">
      <div id="left">
        <canvas id="canvas" width="400" height="400">
    		    Seu navegador não suporta canvas!
    	  </canvas>
      </div>
      <div id="middle">
        <h3>&emsp;&emsp;&emsp;Algoritmos de busca:</h3>
        <h3>Vértice inicial:</h3>
        <label><b>Linha: </b></label>
        <input id="numLinhaVertInicial" type="number" min="20" max="200">
        <label><b>Coluna: </b></label>
        <input id="numColunaVertInicial" type="number" min="20" max="200">
        <h3>Vértice objetivo: </h3>
        <label><b>Linha: </b></label>
        <input id="numLinhaVertObjetivo" type="number" min="20" max="200">
        <label><b>Coluna: </b></label>
        <input id="numColunaVertObjetivo" type="number" min="20" max="200">
        <button onclick="validaVertices()">Validar vértices</button>
        <br></br>
        <button onclick="backtracking()">Backtracking</button>
        <br></br>
        <button onclick="buscaProfundidade()">Busca em Profundidade Limitada</button>
        <br></br>
        <button onclick="buscaLargura()">Busca em Largura</button>
        <br></br>
        <button onclick="buscaOrdenada()">Busca Ordenada</button>
        <br></br>
        <button onclick="buscaGulosa()">Busca Gulosa</button>
        <br></br>
        <button onclick="buscaAEstrela()">Busca A*</button>
        <br></br>
        <button onclick="buscaIDAEstrela()">Busca IDA*</button>
        <br></br>
      </div>
      <div id="right">
        teste
      </div>
    </div>

    <script>

      var tela = document.getElementById("canvas");
      var ctx = tela.getContext("2d");
      var anterior = dt = 0;

      /*************************************************
      *                                                *
      *   Variáveis da geração e controle do labirinto *
      *                                                *
      **************************************************/

      var cols, linhas, espacamento = 20;
      var w = 40;
      var grid = [];                          //Vetor que armazena a matriz toda de maneira linear pra poder gerar o labirinto mais fácil usando backtrack recursivo
      var celulaAtual;
      var pilha = [];
      var terminoGeracaoPassos = true;
      var valorLinhas = 10, valorColunas = 10, valorLargura = 20;

      /*************************************************
      *                                                *
      *     Variáveis de controle das buscas           *
      *                                                *
      **************************************************/

      var matriz;                             //Armazena o labirinto além do vetor grid, sendo este voltado para a realização das buscas
      var verticeInicial = [2];               //posicao 1 representa a identificação da linha e a 2 a identificação da coluna
      var verticeObjetivo = [2];


      function funcaoBotaoGerarCompleto(){
        valorLinhas = parseInt(document.getElementById("numLinhas").value);
        valorColunas = parseInt(document.getElementById("numColunas").value);     ///Converte pra inteiro o valor digitado
        w = parseInt(document.getElementById("numLarguraCelula").value);
        tela.height = Math.ceil((valorLinhas * w)+espacamento*2);                ///Acerta as medições do canvas conforme o valor digitado pelo usuário
        tela.width = Math.ceil((valorColunas * w)+espacamento*2);
        /*if(w < 40 && (valorLinhas < 30 && valorColunas < 30)){
          tela.height = 400;
          tela.width = 400;
        }
        else{
          tela.height = Math.ceil((valorLinhas * w)+espacamento*2);
          tela.width = Math.ceil((valorColunas * w)+espacamento*2);
        }*/
        setup();
        gerarLabirintoCompleto();
        desenhaLabirinto();
        terminoGeracaoPassos = true;                                ///Terminou de gerar o labirinto, logo somente será desenhado na tela o labirinto
      }

      function funcaoBotaoGerarPassoAPasso(){
        valorLinhas = parseInt(document.getElementById("numLinhas").value);
        valorColunas = parseInt(document.getElementById("numColunas").value);     ///Converte pra inteiro o valor digitado
        w = parseInt(document.getElementById("numLarguraCelula").value);
        tela.height = Math.ceil((valorLinhas * w)+espacamento*2);                ///Acerta as medições do canvas conforme o valor digitado pelo usuário
        tela.width = Math.ceil((valorColunas * w)+espacamento*2);
        setup();
        terminoGeracaoPassos = false;                                           ///Atribui como falso para o começo da geração por passos
        desenhaGeracaoLabirintoPorPassos();
      }

      function validaVertices(){
        verticeInicial[0] = parseInt(document.getElementById("numLinhaVertInicial").value);
        verticeInicial[1] = parseInt(document.getElementById("numColunaVertInicial").value);
        verticeObjetivo[0] = parseInt(document.getElementById("numLinhaVertObjetivo").value);
        verticeObjetivo[1] = parseInt(document.getElementById("numColunaVertObjetivo").value);
        if(verticeInicial[0] >= linhas){
          alert("Vértice inicial ultrapassando as linhas do labirintos: {" + 0 + " -> "+ (linhas-1) + "}");
        }
        else{
          if(verticeObjetivo[0] >= linhas){
            alert("Vértice objetivo ultrapassando as linhas do labirintos: {" + 0 + " -> "+ (linhas-1) + "}");
          }
          else{
            if(verticeInicial[1] >= cols){
              alert("Vértice inicial ultrapassando as colunas do labirintos: {" + 0 + " -> "+ (cols-1) + "}");
            }
            else if(verticeObjetivo[1] >= cols){
              alert("Vértice inicial ultrapassando as colunas do labirintos: {" + 0 + " -> "+ (cols-1) + "}");
            }
            else{
              console.log("Validado");
              matriz[verticeInicial[0]][verticeInicial[1]].verticeBusca = 0;
              matriz[verticeObjetivo[0]][verticeObjetivo[1]].verticeBusca = 1;
            }
          }
        }

      }

      function backtracking(){
        var tempoInicial = performance.now();

        console.log("Executando backtracking");
        var pilhaBT = [];
        var visitados = [];//[linhas][cols];            //Matriz de visitados
        for (var i = 0; i < linhas; i++) {
          visitados[i] = [];
          for(var j = 0; j < cols; j++){
            visitados[i][j] = false;
          }
        }

        var fim = matriz[verticeObjetivo[0]][verticeObjetivo[1]];
        var s = matriz[verticeInicial[0]][verticeInicial[1]];
        var n = s;
        visitados[n.i][n.j] = true;                                       //Visitando o primeiro vertice
        pilhaBT.push(n);
        var fracasso = false, sucesso = false;
        while((sucesso == false) && (fracasso == false)){
          var contador = 0;
          for (var i = 0; i < s.wall.length; i++) {
            if(n.wall[i] === false){                                      //Checa se não há parede
              //console.log(i + " ---- "+ n.i + " ------(n) BACKTRACKING ---- " + n.j);
              var auxVizinho = n.getVizinho(i, matriz);                   //Captura a celula do vizinho na matriz
              //console.log(auxVizinho.i + " ------ BACKTRACKING ---- " + auxVizinho.j);
              if(visitados[auxVizinho.i][auxVizinho.j] === false){        //vizinho não visitado
                n = auxVizinho;                                           //Atualiza para o próximo vértice
                visitados[n.i][n.j] = true;                               //Marca como visitado o próximo vértice
                pilhaBT.push(n);
                if(n === fim){                                            //Encontrou o objetivo
                  sucesso = true;
                }
                break;
              }
            }
            contador++;
          }

          if(contador >= 4){          ///Passou todas as operações possíveis -- Fazer o backtracking senão retornar fracasso
            if(n === s){
                fracasso = true;
            }
            else{
                if(pilhaBT.length == 0){
                   fracasso = true;
                   break;
                }
                pilhaBT.pop();                 ///Desempilha e redireciona para o pai
                n = pilhaBT[pilhaBT.length - 1];
            }
          }
        }

        if(fracasso){
          console.log("Fracasso em encontrar a solução");
        }
        else{
          if(sucesso){
            console.log("Sucesso em encontrar a solução");
            var texto = "\nPilha: ";
            for(var i = 0; i < pilhaBT.length; i++){
                texto = texto + "Celula["+pilhaBT[i].i+"]["+pilhaBT[i].j+"]"+ " -- ";
            }
            texto = texto + "\n";
            console.log(texto);
            var numVisitados = 0;
            texto = "\n\nQuem foi visitado: ";
            for (var i = 0; i < linhas; i++) {
              for(var j = 0; j < cols; j++){
                if(visitados[i][j]){
                    texto = texto + "Celula["+i+"]["+j+"] -- ";
                    numVisitados++;
                }
              }
            }
            console.log(texto);
            console.log("\nQuantidade total de vértices visitados: " + numVisitados);
            var tempoFinal = performance.now();
            console.log("\nTempo de execução: " + parseFloat((tempoFinal - tempoInicial)).toFixed(3));    ///Mede o tempo somente na função
          }
        }

      }

      function heuristica(xInicial, yInicial, xFinal, yFinal){
        if(Math.abs(xFinal - xInicial)  <  Math.abs(yFinal - yInicial))
          return Number(Math.abs(xInicial - xFinal) + Math.abs((yInicial - yFinal) - Math.abs(xInicial - xFinal)));
        else
        if(Math.abs(xFinal - xInicial)  >  Math.abs(yFinal - yInicial))
          return Number(Math.abs(yInicial - yFinal) + Math.abs((xInicial - xFinal) - Math.abs(yInicial - yFinal)));
        else
        if(Math.abs(xFinal - xInicial)  ==  Math.abs(yFinal - yInicial))
          return Number(Math.abs(xInicial - xFinal));
      }

      requestAnimationFrame(passo);

      /************************************************
      *                                               *
      *                   passo():                    *
      *  -> Controla o loop de animação e desenho.    *
      *                                               *
      ************************************************/

     function passo(t){
       dt = (t - anterior)/1000;                      //Taxa de quadros
       if(terminoGeracaoPassos===false){
         desenhaGeracaoLabirintoPorPassos();
       }
       else{
         desenhaLabirinto();
       }
       anterior = t;
       requestAnimationFrame(passo);
     }

      /********************************************************************************
      *                                                                               *
      *                         tempoDecorrido(funcao):                               *
      *   -> É passada a função desejada para calcular o tempo de execução da mesma.  *
      *   -> Observação: Se ela esperar parametros, coloque os posteriormente na de   *
      *   claração. Exemplo: console.log(tempoDecorrido(nomeDaFuncao, parametro));    *
      *                                                                               *
      *********************************************************************************/

     function tempoDecorrido(funcao) {
        // pega os argumentos a serem repassados
        var args = Array.prototype.slice.call(arguments, 1);

        // logo antes da execução
        var inicio = performance.now();

        // executa a função passada, passando os argumentos se for o caso
        funcao.apply(null, args);

        // logo após a execução
        return performance.now() - inicio;
    }

      /**************************************************************
      *                                                             *
      *                       setup():                              *
      *  -> Cria a estrutura básica do labirinto definindo linhas,  *
      *  colunas e o ponto inicial de geração do labirinto.         *
      *                                                             *
      ***************************************************************/

     function setup(){
       cols = valorColunas;
       linhas = valorLinhas;
       celularAtual = null;                                         //"Limpa" a celula antes de começar a gerar labirinto
       grid = [];                                                   //"Limpa" o vetor de celulas
       pilha = [];
       matriz = [];                                                 //Cria uma matriz por meio de um vetor de vetores
       for (var i = 0; i < linhas; i++) {
         matriz[i] = [];
         for (var j = 0; j < cols; j++) {
           var cell = new Cell(i, j);
           matriz[i][j] = cell;
           grid.push(cell);
         }
       }
       celulaAtual = grid[0];                                     //Expande a geração do labirinto a partir da célula{0,0}
     }

     /***************************************************************
     *                                                              *
     *                       limparTela():                          *
     *  -> Preenche o canvas com um retângulo cheio visando retirar *
     *  as outras informações já desenhas.                          *
     *                                                              *
     ****************************************************************/

     function limparTela() {
      ctx.fillStyle = "gray";
      ctx.fillRect(0,0, tela.width, tela.height);
      //ctx.clearRect(0, 0, canvas.width, canvas.height);
     }

     /*****************************************************************
     *                                                                *
     *                 gerarLabirintoPorPassos():                      *
     *  -> gera o labirinto passo a passo sendo necessário colocar no *
     *  loop de animação para que termine a geração completa.         *
     *                                                                *
     ******************************************************************/

     function gerarLabirintoPorPassos(){
         celulaAtual.visited = true;
         //PASSO 1
         var proximaCelula = celulaAtual.checarVizinhos(grid, cols, linhas);
         if (proximaCelula) {
           proximaCelula.visited = true;

           // PASSO 2
           pilha.push(celulaAtual);

           // PASSO 3
           removeWalls(celulaAtual, proximaCelula);

           // PASSO 4
           celulaAtual = proximaCelula;
         }else if (pilha.length > 0) {
           celulaAtual = pilha.pop();
           if(celulaAtual===grid[0]){
              terminoGeracaoPassos = true;
              console.log("Terminou geração");
           }
         }
     }

     /*****************************************************
     *                                                    *
     *             gerarLabirintoCompleto():              *
     *  -> gera o labirinto completo de uma vez.          *
     *                                                    *
     ******************************************************/

     function gerarLabirintoCompleto(){
       setup();
       var gerouLabirinto = false;
       while(gerouLabirinto===false){
         celulaAtual.visited = true;
         //PASSO 1
         var proximaCelula = celulaAtual.checarVizinhos(grid, cols, linhas);
         if (proximaCelula) {
           proximaCelula.visited = true;

           // PASSO 2
           pilha.push(celulaAtual);

           // PASSO 3
           removeWalls(celulaAtual, proximaCelula);

           // PASSO 4
           celulaAtual = proximaCelula;
         } else if (pilha.length > 0) {
           celulaAtual = pilha.pop();
           if(celulaAtual===grid[0]){
              gerouLabirinto = true;
              console.log("Terminou geração");
              break;
           }
         }
       }
       desenhaLabirinto();
     }

     function desenhaLabirinto(){
       limparTela();
       for (var i = 0; i < grid.length; i++) {          //Exibe as células
         grid[i].show(ctx, espacamento);
       }
     }

     function desenhaGeracaoLabirintoPorPassos(){
       limparTela();
       for (var i = 0; i < grid.length; i++) {          //Exibe as células
         grid[i].show(ctx, espacamento);
       }
       celulaAtual.colorido(ctx, w, espacamento);
       gerarLabirintoPorPassos();
     }

     /*****************************************************************
     *                                                                *
     *                       removeWalls(a, b):                       *
     *  -> Método importante para geração do labirinto em que remove  *
     *  as paredes entre duas células.                                *
     *                                                                *
     ******************************************************************/

     function removeWalls(a, b) {
       var x = a.j - b.j;           ///Analisa a coluna
       if (x === 1) {
         a.wall[3] = false;
         b.wall[1] = false;
       } else if (x === -1) {
         a.wall[1] = false;
         b.wall[3] = false;
       }
       var y = a.i - b.i;           ///Analisa a linha
       if (y === 1) {
         a.wall[0] = false;
         b.wall[2] = false;
       } else if (y === -1) {
         a.wall[2] = false;
         b.wall[0] = false;
       }
     }
    </script>

  </body>
</html>
