<DOCTYPE! html>
<html lang="pt-br" dir="ltr">
  <head>
    <meta charset="utf-8">
    <script src="cell.js"></script>
    <script src="maze.js"></script>
    <title>Maze Generator</title>
    <style> body {padding: 20px; margin: 0;} canvas {vertical-align: top;} </style>

    <style>
      body {
          background-color: lightblue;
          color:black;
      }
    </style>
    <style type="text/css">
    * {margin: 0; padding: 0;}
    #container {display: flex; height: 100%; width:100%; font-size: 0;}
    #left, #middle, #right {display: inline-block; *display: inline; zoom: 1; vertical-align: top; font-size: 15px;}
    #left {margin-right: 10px;}
    #middle {flex:1; background: yellow; border:2px solid black ; margin-right: 10px;}
    #right {flex:1; background: yellow; border:2px solid black ; }
    canvas{border:2px solid black ; }
    /*div.container{
      width: 110px;
      height: 110px;
      overflow: scroll;
    }*/
    </style>

    <style>
      table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
      }

      td, th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }

      tr:nth-child(even) {
        background-color: #dddddd;
      }
    </style>
  </head>
  <body>
    <h1 align="center"><u>Trabalho de Inteligência Artificial</u> (2019/1)</h1>
    <br></br>
    <h2>&emsp;&emsp;Tema: Buscas em um labirinto </h2>
    <h2>&emsp;&emsp;Estratégia de geração do labirinto: backtrack recursivo(Recursive backtracker) </h3>
    <br></br>
    <h2>&emsp;&emsp;Geração de labirinto</h2>
    <br></br>
    <label><b>Linhas: </b></label>
    <input id="numLinhas" type="number" min="20" max="200">
    <label><b>Colunas: </b></label>
    <input id="numColunas" type="number" min="20" max="200">
    <label><b>Largura celula: </b></label>
    <input id="numLarguraCelula" type="number" min="20" max="40">
    <button onclick="funcaoBotaoGerarCompleto()">Gerar(Completo)</button>
    <button onclick="funcaoBotaoGerarPassoAPasso()">Gerar(Passo a passo)</button>
    <br></br>
    <h2>Exibir: </h2>
    <br></br>
    <input type="checkbox" id="cbCaminhoSolucao"><b> - Caminho Solução &emsp;</b>
    <input type="checkbox" id="cdLinhasGrade"><b> - Linhas de Grade &emsp;</b>
    <br></br>

    <div id="container">
      <div id="left">
        <canvas id="canvas" width="400" height="400">
    		    Seu navegador não suporta canvas!
    	  </canvas>
      </div>
      <div id="middle">
        <h3>&emsp;&emsp;&emsp;Algoritmos de busca:</h3>
        <h3>Vértice inicial:</h3>
        <label><b>Linha: </b></label>
        <input id="numLinhaVertInicial" type="number" min="20" max="200">
        <label><b>Coluna: </b></label>
        <input id="numColunaVertInicial" type="number" min="20" max="200">
        <h3>Vértice objetivo: </h3>
        <label><b>Linha: </b></label>
        <input id="numLinhaVertObjetivo" type="number" min="20" max="200">
        <label><b>Coluna: </b></label>
        <input id="numColunaVertObjetivo" type="number" min="20" max="200">
        <button onclick="validaVertices()">Validar vértices</button>
        <br></br>
        <button onclick="backtracking()">Backtracking</button>
        <br></br>
        <button onclick="buscaProfundidadeLimitada()">Busca em Profundidade Limitada</button>
        <br></br>
        <button onclick="buscaEmLargura()">Busca em Largura</button>
        <br></br>
        <button onclick="buscaOrdenada()">Busca Ordenada</button>
        <br></br>
        <button onclick="buscaGulosa()">Busca Gulosa</button>
        <br></br>
        <button onclick="buscaAEstrela()">Busca A*</button>
        <br></br>
        <button onclick="buscaIDAEstrela()">Busca IDA*</button>
        <br></br>
      </div>
      <div id="right">
        teste
      </div>
    </div>

    <script>

      var tela = document.getElementById("canvas");
      var ctx = tela.getContext("2d");
      var anterior = dt = 0;

      /*************************************************
      *                                                *
      *   Variáveis da geração e controle do labirinto *
      *                                                *
      **************************************************/
      var valorLinhas = 10, valorColunas = 10, valorLargura = 20, espacamento = 30;
      var labirinto = new Maze(valorLinhas,valorColunas,valorLargura);

      /**********************************************
      *   Variaveis do controle de estado:          *
      *   0 => Não faz nada;                        *
      *   1 => Desenha labirinto;                   *
      *   2 => Desenha labirinto por passos;        *
      ***********************************************/
      var estado = 0;

      /*************************************************
      *                                                *
      *     Variáveis de controle das buscas           *
      *                                                *
      **************************************************/

      var verticeInicial = [2];               //posicao 1 representa a identificação da linha e a 2 a identificação da coluna
      var verticeObjetivo = [2];

      function funcaoBotaoGerarCompleto(){
        valorLinhas = parseInt(document.getElementById("numLinhas").value);
        valorColunas = parseInt(document.getElementById("numColunas").value);     ///Converte pra inteiro o valor digitado
        valorLargura = parseInt(document.getElementById("numLarguraCelula").value);
        tela.height = Math.ceil((valorLinhas * valorLargura)+espacamento*2);                ///Acerta as medições do canvas conforme o valor digitado pelo usuário
        tela.width = Math.ceil((valorColunas * valorLargura)+espacamento*2);
        labirinto = new Maze(valorLinhas,valorColunas,valorLargura);
        labirinto.gerarLabirintoCompleto();
        estado = 1;
      }

      function funcaoBotaoGerarPassoAPasso(){
        valorLinhas = parseInt(document.getElementById("numLinhas").value);
        valorColunas = parseInt(document.getElementById("numColunas").value);             //Converte pra inteiro o valor digitado
        valorLargura = parseInt(document.getElementById("numLarguraCelula").value);
        tela.height = Math.ceil((valorLinhas * valorLargura)+espacamento*2);              //Acerta as medições do canvas conforme o valor digitado pelo usuário
        tela.width = Math.ceil((valorColunas * valorLargura)+espacamento*2);
        labirinto = new Maze(valorLinhas,valorColunas,valorLargura);
        labirinto.terminoGeracaoPassos = false;                                           //Atribui como falso para o começo da geração por passos
        labirinto.gerarLabirintoPorPassos(estado);
        estado = 2;
      }

      function validaVertices(){
        verticeInicial[0] = parseInt(document.getElementById("numLinhaVertInicial").value);
        verticeInicial[1] = parseInt(document.getElementById("numColunaVertInicial").value);
        verticeObjetivo[0] = parseInt(document.getElementById("numLinhaVertObjetivo").value);
        verticeObjetivo[1] = parseInt(document.getElementById("numColunaVertObjetivo").value);
        if(verticeInicial[0] >= labirinto.linhas){
          alert("Vértice inicial ultrapassando as linhas do labirintos: {" + 0 + " -> "+ (linhas-1) + "}");
        }
        else{
          if(verticeObjetivo[0] >= labirinto.linhas){
            alert("Vértice objetivo ultrapassando as linhas do labirintos: {" + 0 + " -> "+ (linhas-1) + "}");
          }
          else{
            if(verticeInicial[1] >= labirinto.colunas){
              alert("Vértice inicial ultrapassando as colunas do labirintos: {" + 0 + " -> "+ (cols-1) + "}");
            }
            else if(verticeObjetivo[1] >= labirinto.colunas){
              alert("Vértice inicial ultrapassando as colunas do labirintos: {" + 0 + " -> "+ (cols-1) + "}");
            }
            else{
              console.log("Validado");
            }
          }
        }
      }

      function backtracking(){
        labirinto.backtracking(verticeInicial, verticeObjetivo);
      }

      function buscaProfundidadeLimitada(){
        var limite = prompt("Digite um valor para o limite da busca em profundidade: ", 1000000);
        if (limite == null || limite < 2) {
          alert("Digite um número valido maior que 1");
        } else {
          console.log(parseInt(limite));
          labirinto.buscaProfundidadeLimitada(verticeInicial, verticeObjetivo, parseInt(limite));
        }
      }

      function buscaEmLargura(){
        labirinto.buscaEmLargura(verticeInicial, verticeObjetivo);
      }

      function buscaGulosa(){
        labirinto.buscaGulosa(verticeInicial, verticeObjetivo);
      }

      function tableCreate(){
        var body = document.body,
            tbl  = document.createElement('table');
        tbl.style.width  = '100px';
        tbl.style.border = '1px solid black';

        for(var i = 0; i < 5; i++){
            var tr = tbl.insertRow();
            for(var j = 0; j < 1; j++){
                if(i == 2 && j == 1){
                    break;
                } else {
                    var td = tr.insertCell();
                    td.appendChild(document.createTextNode('Cell'));
                    td.style.border = '1px solid black';
                    if(i == 1 && j == 1){
                        td.setAttribute('rowSpan', '2');
                    }
                }
            }
        }
        body.appendChild(tbl);
    }
    tableCreate();

      function heuristica(xInicial, yInicial, xFinal, yFinal){
        if(Math.abs(xFinal - xInicial)  <  Math.abs(yFinal - yInicial))
          return Number(Math.abs(xInicial - xFinal) + Math.abs((yInicial - yFinal) - Math.abs(xInicial - xFinal)));
        else
        if(Math.abs(xFinal - xInicial)  >  Math.abs(yFinal - yInicial))
          return Number(Math.abs(yInicial - yFinal) + Math.abs((xInicial - xFinal) - Math.abs(yInicial - yFinal)));
        else
        if(Math.abs(xFinal - xInicial)  ==  Math.abs(yFinal - yInicial))
          return Number(Math.abs(xInicial - xFinal));
      }

      requestAnimationFrame(passo);

      /************************************************
      *                                               *
      *                   passo():                    *
      *  -> Controla o loop de animação e desenho.    *
      *                                               *
      ************************************************/

     function passo(t){
       dt = (t - anterior)/1000;                      //Taxa de quadros
       limparTela();
       switch(estado){
         case 0:
            ///Não faz nada
         break;
         case 1:
            labirinto.desenharLabirinto(ctx, espacamento);
            //console.log("Estado 1");
         break;
         case 2:
            labirinto.desenharGeracaoLabirintoPorPassos(ctx, espacamento, estado);
         break;
         default:
            console.log("Problema no controle de estados");
       }

       var checkBoxDados = document.getElementById("cbCaminhoSolucao").checked;
       if(checkBoxDados){                             //Desenhar solução
         labirinto.desenharSolucao(ctx, espacamento);
       }
       checkBoxDados = document.getElementById("cdLinhasGrade").checked;
       if(checkBoxDados){
         labirinto.desenharLinhasGrade(ctx, espacamento);
       }
       anterior = t;
       requestAnimationFrame(passo);
     }

      /********************************************************************************
      *                                                                               *
      *                         tempoDecorrido(funcao):                               *
      *   -> É passada a função desejada para calcular o tempo de execução da mesma.  *
      *   -> Observação: Se ela esperar parametros, coloque os posteriormente na de   *
      *   claração. Exemplo: console.log(tempoDecorrido(nomeDaFuncao, parametro));    *
      *                                                                               *
      *********************************************************************************/

     function tempoDecorrido(funcao) {
        // pega os argumentos a serem repassados
        var args = Array.prototype.slice.call(arguments, 1);

        // logo antes da execução
        var inicio = performance.now();

        // executa a função passada, passando os argumentos se for o caso
        funcao.apply(null, args);

        // logo após a execução
        return performance.now() - inicio;
    }

      /**************************************************************
      *                                                             *
      *                       setup():                              *
      *  -> Cria a estrutura básica do labirinto definindo linhas,  *
      *  colunas e o ponto inicial de geração do labirinto.         *
      *                                                             *
      ***************************************************************/

     function setup(){
       cols = valorColunas;
       linhas = valorLinhas;
       celularAtual = null;                                         //"Limpa" a celula antes de começar a gerar labirinto
       grid = [];                                                   //"Limpa" o vetor de celulas
       pilha = [];
       matriz = [];                                                 //Cria uma matriz por meio de um vetor de vetores
       for (var i = 0; i < linhas; i++) {
         matriz[i] = [];
         for (var j = 0; j < cols; j++) {
           var cell = new Cell(i, j);
           matriz[i][j] = cell;
           grid.push(cell);
         }
       }
       celulaAtual = grid[0];                                     //Expande a geração do labirinto a partir da célula{0,0}
     }

     /***************************************************************
     *                                                              *
     *                       limparTela():                          *
     *  -> Preenche o canvas com um retângulo cheio visando retirar *
     *  as outras informações já desenhas.                          *
     *                                                              *
     ****************************************************************/

     function limparTela() {
      ctx.fillStyle = "gray";
      ctx.fillRect(0,0, tela.width, tela.height);
      //ctx.clearRect(0, 0, canvas.width, canvas.height);
     }

     /*****************************************************************
     *                                                                *
     *                 gerarLabirintoPorPassos():                      *
     *  -> gera o labirinto passo a passo sendo necessário colocar no *
     *  loop de animação para que termine a geração completa.         *
     *                                                                *
     ******************************************************************/

     function gerarLabirintoPorPassos(){
         celulaAtual.visited = true;
         //PASSO 1
         var proximaCelula = celulaAtual.checarVizinhos(grid, cols, linhas);
         if (proximaCelula) {
           proximaCelula.visited = true;

           // PASSO 2
           pilha.push(celulaAtual);

           // PASSO 3
           removeWalls(celulaAtual, proximaCelula);

           // PASSO 4
           celulaAtual = proximaCelula;
         }else if (pilha.length > 0) {
           celulaAtual = pilha.pop();
           if(celulaAtual===grid[0]){
              terminoGeracaoPassos = true;
              console.log("Terminou geração");
           }
         }
     }

     /*****************************************************
     *                                                    *
     *             gerarLabirintoCompleto():              *
     *  -> gera o labirinto completo de uma vez.          *
     *                                                    *
     ******************************************************/

     function gerarLabirintoCompleto(){
       setup();
       var gerouLabirinto = false;
       while(gerouLabirinto===false){
         celulaAtual.visited = true;
         //PASSO 1
         var proximaCelula = celulaAtual.checarVizinhos(grid, cols, linhas);
         if (proximaCelula) {
           proximaCelula.visited = true;

           // PASSO 2
           pilha.push(celulaAtual);

           // PASSO 3
           removeWalls(celulaAtual, proximaCelula);

           // PASSO 4
           celulaAtual = proximaCelula;
         } else if (pilha.length > 0) {
           celulaAtual = pilha.pop();
           if(celulaAtual===grid[0]){
              gerouLabirinto = true;
              console.log("Terminou geração");
              break;
           }
         }
       }
       desenhaLabirinto();
     }

     function desenhaLabirinto(){
       limparTela();
       for (var i = 0; i < grid.length; i++) {          //Exibe as células
         grid[i].show(ctx, espacamento);
       }
     }

     function desenhaGeracaoLabirintoPorPassos(){
       limparTela();
       for (var i = 0; i < grid.length; i++) {          //Exibe as células
         grid[i].show(ctx, espacamento);
       }
       celulaAtual.colorido(ctx, w, espacamento);
       gerarLabirintoPorPassos();
     }

     /*****************************************************************
     *                                                                *
     *                       removeWalls(a, b):                       *
     *  -> Método importante para geração do labirinto em que remove  *
     *  as paredes entre duas células.                                *
     *                                                                *
     ******************************************************************/

     function removeWalls(a, b) {
       var x = a.j - b.j;           ///Analisa a coluna
       if (x === 1) {
         a.wall[3] = false;
         b.wall[1] = false;
       } else if (x === -1) {
         a.wall[1] = false;
         b.wall[3] = false;
       }
       var y = a.i - b.i;           ///Analisa a linha
       if (y === 1) {
         a.wall[0] = false;
         b.wall[2] = false;
       } else if (y === -1) {
         a.wall[2] = false;
         b.wall[0] = false;
       }
     }
    </script>

  </body>
</html>
